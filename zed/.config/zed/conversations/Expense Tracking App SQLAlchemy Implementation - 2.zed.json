{"id":"e848b797-dcc2-46f0-a34e-01ffe7b65a3a","zed":"context","version":"0.4.0","text":"\n\n\nHi!\nPlease, help me to build the app for expenses tracking.\nHere is the idea:\nI want to query the sqlalchemy db of imassages on mac and perform some analytics.\nPath to db: DB_PATH = \"/Users/romannovikov/Library/Messages/chat.db\"\n\nQuery: \"text\" LIKE '%Payment of AED%'\n\nThe app should categorise the expenses by categories: grocery, restaurant, entertainment, clothes, and other spendings categories.\n\nHere is the several examples of messages:\n- Payment of AED 12 was done at Careem using your Wio Personal card 1731 with Own AED funds\n- Payment of AED 68.8 was done at Al Maya using your Wio Personal card 1731 with Own AED funds\n- Payment of AED 16 was done at Amazon using your Wio Personal card 1731 with Own AED funds\n- Payment of AED 39 was done at Bkk station by thai using your Wio Personal card 1731 with Own AED funds\n- Payment of AED 48.3 was done at Hanoi restaurants jlt using your Wio Personal card 1731 with Own AED funds\n- Payment of AED 28.8 was done at Carrefour using your Wio Personal card 1731 with Own AED funds\n- Payment of AED 3.99 was done at Apple using your Wio Personal card 1731 with Own AED funds\n- Payment of AED 20 was done at Rta Jumeirah Lake using your Wio Personal card 1731 with Own AED funds\n\nMy final goal to build the expanses tracking app that allows me to track expenses by categories, and plan my savings more clearly.\nThe first implemetatin can be done as the CLI tool.\n\nHow to make such an app?\nCan you assist me, please.\nThanks in advance!\n\n# Building an Expense Tracking App for iMessage Data\n\nI'll help you build a CLI expense tracking app that categorizes expenses from your iMessage database. Let's break this down into steps:\n\n## Step 1: Create a Basic Structure\n\n```python\nimport sqlite3\nimport re\nimport argparse\nfrom datetime import datetime\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom tabulate import tabulate\n\nDB_PATH = \"/Users/romannovikov/Library/Messages/chat.db\"\n\n# Define categories and related keywords\nCATEGORIES = {\n    \"grocery\": [\"carrefour\", \"al maya\", \"supermarket\", \"grocery\", \"lulu\", \"spinneys\", \"waitrose\"],\n    \"restaurant\": [\"restaurant\", \"cafe\", \"coffee\", \"bkk\", \"thai\", \"hanoi\", \"food\", \"bistro\", \"eatery\"],\n    \"entertainment\": [\"cinema\", \"movie\", \"theatre\", \"event\", \"concert\", \"game\", \"amazon\", \"apple\"],\n    \"transport\": [\"careem\", \"uber\", \"taxi\", \"rta\", \"metro\", \"bus\", \"petrol\", \"gas\", \"fuel\"],\n    \"clothes\": [\"apparel\", \"fashion\", \"zara\", \"h&m\", \"clothing\", \"shoes\", \"dress\", \"wear\"],\n    \"utilities\": [\"dewa\", \"internet\", \"phone\", \"mobile\", \"du\", \"etisalat\", \"utility\"],\n    \"other\": []  # Default category for unmatched items\n}\n\ndef extract_details(message):\n    \"\"\"Extract amount, merchant, and date from message\"\"\"\n    amount_match = re.search(r'AED\\s+(\\d+\\.?\\d*)', message)\n    merchant_match = re.search(r'done at ([^using]+)', message)\n    \n    amount = float(amount_match.group(1)) if amount_match else 0.0\n    merchant = merchant_match.group(1).strip() if merchant_match else \"Unknown\"\n    \n    return {\n        \"amount\": amount,\n        \"merchant\": merchant\n    }\n\ndef categorize_expense(merchant):\n    \"\"\"Categorize merchant based on keywords\"\"\"\n    merchant_lower = merchant.lower()\n    \n    for category, keywords in CATEGORIES.items():\n        for keyword in keywords:\n            if keyword in merchant_lower:\n                return category\n    \n    return \"other\"  # Default category\n\ndef fetch_expenses(days=None):\n    \"\"\"Fetch expenses from the iMessage database\"\"\"\n    conn = sqlite3.connect(DB_PATH)\n    cursor = conn.cursor()\n    \n    query = \"SELECT text, date FROM message WHERE text LIKE '%Payment of AED%'\"\n    \n    if days:\n        # Calculate date threshold in iMessage timestamp format\n        # iMessage timestamps are in Mac Absolute Time format (seconds since 2001-01-01)\n        # We would need to convert this properly\n        pass\n        \n    cursor.execute(query)\n    results = cursor.fetchall()\n    conn.close()\n    \n    expenses = []\n    for text, date in results:\n        details = extract_details(text)\n        # Convert iMessage date to datetime (would need proper conversion)\n        # details[\"date\"] = convert_imessage_date(date)\n        details[\"category\"] = categorize_expense(details[\"merchant\"])\n        details[\"message\"] = text\n        expenses.append(details)\n    \n    return expenses\n```\n\n## Step 2: Add Analytics and Reporting Functions\n\n```python\ndef analyze_expenses(expenses):\n    \"\"\"Generate analytics for expenses\"\"\"\n    if not expenses:\n        return {\"error\": \"No expenses found\"}\n    \n    # Create DataFrame for easier analysis\n    df = pd.DataFrame(expenses)\n    \n    # Total amount\n    total_spent = df[\"amount\"].sum()\n    \n    # Category breakdown\n    category_totals = df.groupby(\"category\")[\"amount\"].sum().to_dict()\n    \n    # Top merchants\n    top_merchants = df.groupby(\"merchant\")[\"amount\"].sum().sort_values(ascending=False).head(5).to_dict()\n    \n    return {\n        \"total_spent\": total_spent,\n        \"category_totals\": category_totals,\n        \"top_merchants\": top_merchants\n    }\n\ndef display_report(expenses, analytics):\n    \"\"\"Display expense report in the terminal\"\"\"\n    print(\"\\n===== EXPENSE REPORT =====\")\n    print(f\"Total Spent: AED {analytics['total_spent']:.2f}\")\n    \n    print(\"\\n----- Category Breakdown -----\")\n    category_data = [(category, f\"AED {amount:.2f}\", f\"{(amount/analytics['total_spent'])*100:.1f}%\") \n                     for category, amount in analytics['category_totals'].items()]\n    print(tabulate(category_data, headers=[\"Category\", \"Amount\", \"Percentage\"], tablefmt=\"grid\"))\n    \n    print(\"\\n----- Top Merchants -----\")\n    merchant_data = [(merchant, f\"AED {amount:.2f}\") \n                     for merchant, amount in analytics['top_merchants'].items()]\n    print(tabulate(merchant_data, headers=[\"Merchant\", \"Amount\"], tablefmt=\"grid\"))\n    \n    print(\"\\n----- Recent Transactions -----\")\n    recent_data = [(exp[\"merchant\"], f\"AED {exp['amount']:.2f}\", exp[\"category\"]) \n                   for exp in expenses[:10]]  # Last 10 transactions\n    print(tabulate(recent_data, headers=[\"Merchant\", \"Amount\", \"Category\"], tablefmt=\"grid\"))\n    \ndef plot_expenses(analytics):\n    \"\"\"Generate and display expense charts\"\"\"\n    # Pie chart for category distribution\n    plt.figure(figsize=(12, 6))\n    plt.subplot(1, 2, 1)\n    categories = list(analytics[\"category_totals\"].keys())\n    amounts = list(analytics[\"category_totals\"].values())\n    plt.pie(amounts, labels=categories, autopct='%1.1f%%')\n    plt.title('Expenses by Category')\n    \n    # Bar chart for top merchants\n    plt.subplot(1, 2, 2)\n    merchants = list(analytics[\"top_merchants\"].keys())\n    merchant_amounts = list(analytics[\"top_merchants\"].values())\n    plt.bar(merchants, merchant_amounts)\n    plt.title('Top Merchants')\n    plt.xticks(rotation=45, ha='right')\n    plt.tight_layout()\n    plt.show()\n```\n\n## Step 3: Create the Main CLI Application\n\n```python\ndef main():\n    parser = argparse.ArgumentParser(description='Expense Tracker for iMessage Data')\n    parser.add_argument('--days', type=int, help='Number of past days to analyze')\n    parser.add_argument('--plot', action='store_true', help='Generate and display charts')\n    parser.add_argument('--output', help='Save report to file')\n    args = parser.parse_args()\n    \n    print(\"Fetching expenses from iMessage database...\")\n    try:\n        expenses = fetch_expenses(args.days)\n        \n        if not expenses:\n            print(\"No expenses found in the database.\")\n            return\n        \n        print(f\"Found {len(expenses)} expenses.\")\n        analytics = analyze_expenses(expenses)\n        display_report(expenses, analytics)\n        \n        if args.plot:\n            plot_expenses(analytics)\n            \n        if args.output:\n            # Save report to file\n            # Implementation depends on desired output format\n            pass\n            \n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n## Step 4: Adding Data Persistence for Manual Categorization\n\n```python\ndef save_categorized_expenses(expenses, filename=\"expenses.json\"):\n    \"\"\"Save categorized expenses for future reference\"\"\"\n    import json\n    \n    with open(filename, 'w') as f:\n        json.dump(expenses, f, indent=2)\n    \n    print(f\"Expenses saved to {filename}\")\n\ndef load_categorized_expenses(filename=\"expenses.json\"):\n    \"\"\"Load previously categorized expenses\"\"\"\n    import json\n    import os\n    \n    if os.path.exists(filename):\n        with open(filename, 'r') as f:\n            return json.load(f)\n    return []\n\ndef update_category(expenses, index, new_category):\n    \"\"\"Update category for a specific expense\"\"\"\n    if 0 <= index < len(expenses):\n        expenses[index][\"category\"] = new_category\n        print(f\"Updated category for {expenses[index]['merchant']} to {new_category}\")\n    else:\n        print(\"Invalid index\")\n    return expenses\n```\n\n## Installation and Dependencies\n\n1. Save all this code in a file named `expense_tracker.py`\n\n2. Install the required dependencies:\n```bash\npip install pandas matplotlib tabulate\n```\n\n## Using the App\n\nRun the basic expense report:\n```bash\npython expense_tracker.py\n```\n\nTo generate plots:\n```bash\npython expense_tracker.py --plot\n```\n\n## Next Steps for Improving the App\n\n1. **Better date handling**: Correctly convert iMessage's timestamp format to Python datetime\n\n2. **More detailed categorization**: Add a machine learning model to improve categorization accuracy\n\n3. **Budget tracking**: Add ability to set budgets and track progress\n\n4. **Web interface**: Create a simple web dashboard using Flask or Streamlit\n\n5. **Export capabilities**: Add options to export data to CSV or Excel\n\n6. **Manual category correction**: Add interactive prompt to manually correct categories\n\n## Note on iMessage Database Access\n\nYou might need to grant your terminal app Full Disk Access in System Preferences > Security & Privacy > Privacy to access the iMessage database.\n\nWould you like me to expand on any specific part of this implementation?\nHow can I split functionality by functional modules and organize it properly for further support. Additionaly, I want to make this project using uv package manager. Thanks!\n# Organizing Your Expense Tracker Project with Modularity and uv\n\nLet's reorganize the project with better modularity and set it up using the uv package manager. This structure will make your code more maintainable and easier to extend.\n\n## Project Structure\n\nHere's a recommended directory structure for your expense tracker app:\n\n```\nexpense-tracker/\n├── .gitignore\n├── README.md\n├── pyproject.toml\n├── requirements.txt\n├── expenses.json\n└── src/\n    ├── __init__.py\n    ├── main.py\n    ├── db/\n    │   ├── __init__.py\n    │   └── data_source.py\n    ├── models/\n    │   ├── __init__.py\n    │   └── expense.py\n    ├── services/\n    │   ├── __init__.py\n    │   ├── categorizer.py\n    │   ├── parser.py\n    │   └── analytics.py\n    ├── ui/\n    │   ├── __init__.py\n    │   ├── cli.py\n    │   └── visualization.py\n    └── utils/\n        ├── __init__.py\n        ├── config.py\n        └── date_utils.py\n```\n\n## Setting Up with uv\n\nFirst, let's install `uv` if you haven't already:\n\n```bash\npip install uv\n```\n\nNow, let's create the project files and structure:\n\n### 1. First, create `pyproject.toml`:\n\n```toml\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[project]\nname = \"expense-tracker\"\nversion = \"0.1.0\"\ndescription = \"Expense tracking app that analyzes iMessage payment data\"\nreadme = \"README.md\"\nrequires-python = \">=3.8\"\nauthors = [\n    {name = \"Your Name\", email = \"your.email@example.com\"},\n]\ndependencies = [\n    \"pandas\",\n    \"matplotlib\",\n    \"tabulate\",\n    \"sqlalchemy\",\n]\n\n[project.scripts]\nexpense-tracker = \"src.main:main\"\n\n[tool.hatch.build.targets.wheel]\npackages = [\"src\"]\n\n[tool.ruff]\nline-length = 100\n```\n\n### 2. Create `requirements.txt`:\n\n```\npandas>=2.0.0\nmatplotlib>=3.5.0\ntabulate>=0.8.10\nsqlalchemy>=2.0.0\npytest>=7.0.0\n```\n\n### 3. Now let's implement the modules:\n\n#### `src/__init__.py`\n```python\n# Initialize package\n```\n\n#### `src/db/data_source.py`\n```python\nimport sqlite3\nfrom typing import List, Dict, Any, Optional\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nclass MessageDatabase:\n    \"\"\"Data source for accessing iMessage database\"\"\"\n    \n    def __init__(self, db_path: str):\n        \"\"\"Initialize database connection\"\"\"\n        self.db_path = db_path\n    \n    def fetch_payment_messages(self, days: Optional[int] = None) -> List[Dict[str, Any]]:\n        \"\"\"Fetch payment messages from the database\n        \n        Args:\n            days: Optional number of days to limit the search\n            \n        Returns:\n            List of dictionaries with message text and date\n        \"\"\"\n        try:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            query = \"SELECT text, date FROM message WHERE text LIKE '%Payment of AED%'\"\n            \n            if days:\n                # In a real implementation, we'd add date filtering\n                # This would require converting days to iMessage timestamp format\n                pass\n                \n            cursor.execute(query)\n            results = cursor.fetchall()\n            conn.close()\n            \n            return [{\"text\": text, \"date\": date} for text, date in results]\n            \n        except Exception as e:\n            logger.error(f\"Database error: {e}\")\n            return []\n```\n\n#### `src/models/expense.py`\n```python\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Optional\n\n@dataclass\nclass Expense:\n    \"\"\"Representation of an expense transaction\"\"\"\n    amount: float\n    merchant: str\n    category: str\n    date: Optional[datetime] = None\n    message: str = \"\"\n    \n    def to_dict(self):\n        \"\"\"Convert expense to dictionary\"\"\"\n        result = {\n            \"amount\": self.amount,\n            \"merchant\": self.merchant,\n            \"category\": self.category,\n            \"message\": self.message\n        }\n        \n        if self.date:\n            result[\"date\"] = self.date.isoformat()\n            \n        return result\n    \n    @classmethod\n    def from_dict(cls, data):\n        \"\"\"Create expense from dictionary\"\"\"\n        expense = cls(\n            amount=data[\"amount\"],\n            merchant=data[\"merchant\"],\n            category=data[\"category\"],\n            message=data.get(\"message\", \"\")\n        )\n        \n        if \"date\" in data and data[\"date\"]:\n            try:\n                expense.date = datetime.fromisoformat(data[\"date\"])\n            except:\n                pass\n                \n        return expense\n```\n\n#### `src/services/parser.py`\n```python\nimport re\nfrom typing import Dict, Any, Optional\nfrom datetime import datetime\n\ndef extract_payment_details(message: str) -> Dict[str, Any]:\n    \"\"\"Extract payment details from message text\n    \n    Args:\n        message: The payment message text\n        \n    Returns:\n        Dictionary with extracted details (amount, merchant)\n    \"\"\"\n    amount_match = re.search(r'AED\\s+(\\d+\\.?\\d*)', message)\n    merchant_match = re.search(r'done at ([^using]+)', message)\n    \n    amount = float(amount_match.group(1)) if amount_match else 0.0\n    merchant = merchant_match.group(1).strip() if merchant_match else \"Unknown\"\n    \n    return {\n        \"amount\": amount,\n        \"merchant\": merchant,\n        \"message\": message\n    }\n\ndef convert_imessage_date(timestamp: int) -> Optional[datetime]:\n    \"\"\"Convert iMessage timestamp to Python datetime\n    \n    Args:\n        timestamp: iMessage timestamp (seconds since 2001-01-01)\n        \n    Returns:\n        Python datetime object\n    \"\"\"\n    if not timestamp:\n        return None\n        \n    # iMessage uses Mac Absolute Time: seconds since 2001-01-01\n    # To convert to Unix timestamp (seconds since 1970-01-01),\n    # add the difference between epochs: 978307200 seconds\n    unix_timestamp = timestamp + 978307200\n    \n    return datetime.fromtimestamp(unix_timestamp)\n```\n\n#### `src/services/categorizer.py`\n```python\nfrom typing import Dict, List\n\nclass ExpenseCategorizer:\n    \"\"\"Categorizes expenses based on merchant names\"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize with default categories and keywords\"\"\"\n        self.categories: Dict[str, List[str]] = {\n            \"grocery\": [\"carrefour\", \"al maya\", \"supermarket\", \"grocery\", \"lulu\", \"spinneys\", \"waitrose\"],\n            \"restaurant\": [\"restaurant\", \"cafe\", \"coffee\", \"bkk\", \"thai\", \"hanoi\", \"food\", \"bistro\", \"eatery\"],\n            \"entertainment\": [\"cinema\", \"movie\", \"theatre\", \"event\", \"concert\", \"game\", \"amazon\", \"apple\"],\n            \"transport\": [\"careem\", \"uber\", \"taxi\", \"rta\", \"metro\", \"bus\", \"petrol\", \"gas\", \"fuel\"],\n            \"clothes\": [\"apparel\", \"fashion\", \"zara\", \"h&m\", \"clothing\", \"shoes\", \"dress\", \"wear\"],\n            \"utilities\": [\"dewa\", \"internet\", \"phone\", \"mobile\", \"du\", \"etisalat\", \"utility\"],\n            \"other\": []  # Default category\n        }\n    \n    def categorize(self, merchant: str) -> str:\n        \"\"\"Categorize a merchant based on keywords\n        \n        Args:\n            merchant: The merchant name\n            \n        Returns:\n            Category name\n        \"\"\"\n        merchant_lower = merchant.lower()\n        \n        for category, keywords in self.categories.items():\n            for keyword in keywords:\n                if keyword in merchant_lower:\n                    return category\n        \n        return \"other\"  # Default category\n    \n    def add_keyword(self, category: str, keyword: str) -> None:\n        \"\"\"Add a new keyword to a category\n        \n        Args:\n            category: Category name\n            keyword: Keyword to add\n        \"\"\"\n        if category in self.categories:\n            self.categories[category].append(keyword.lower())\n    \n    def add_category(self, category: str, keywords: List[str] = None) -> None:\n        \"\"\"Add a new category with optional keywords\n        \n        Args:\n            category: New category name\n            keywords: List of keywords for this category\n        \"\"\"\n        if category not in self.categories:\n            self.categories[category] = keywords or []\n```\n\n#### `src/services/analytics.py`\n```python\nfrom typing import List, Dict, Any\nimport pandas as pd\nfrom src.models.expense import Expense\n\nclass ExpenseAnalyzer:\n    \"\"\"Analyzes expense data and generates reports\"\"\"\n    \n    def analyze(self, expenses: List[Expense]) -> Dict[str, Any]:\n        \"\"\"Generate analytics for a list of expenses\n        \n        Args:\n            expenses: List of Expense objects\n            \n        Returns:\n            Dictionary containing analysis results\n        \"\"\"\n        if not expenses:\n            return {\"error\": \"No expenses found\"}\n        \n        # Convert to DataFrame for easier analysis\n        df = pd.DataFrame([exp.to_dict() for exp in expenses])\n        \n        # Total amount\n        total_spent = df[\"amount\"].sum()\n        \n        # Category breakdown\n        category_totals = df.groupby(\"category\")[\"amount\"].sum().to_dict()\n        \n        # Top merchants\n        top_merchants = df.groupby(\"merchant\")[\"amount\"].sum().sort_values(ascending=False).head(5).to_dict()\n        \n        # Monthly breakdown if dates are available\n        monthly_summary = {}\n        if \"date\" in df.columns and df[\"date\"].notna().any():\n            df[\"month\"] = pd.to_datetime(df[\"date\"]).dt.strftime('%Y-%m')\n            monthly_summary = df.groupby(\"month\")[\"amount\"].sum().to_dict()\n        \n        return {\n            \"total_spent\": total_spent,\n            \"category_totals\": category_totals,\n            \"top_merchants\": top_merchants,\n            \"monthly_summary\": monthly_summary\n        }\n```\n\n#### `src/ui/cli.py`\n```python\nimport argparse\nfrom tabulate import tabulate\nfrom typing import List, Dict, Any\nfrom src.models.expense import Expense\n\nclass ExpenseTrackerCLI:\n    \"\"\"Command-line interface for the expense tracker\"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize CLI parser\"\"\"\n        self.parser = argparse.ArgumentParser(description='Expense Tracker for iMessage Data')\n        self._setup_arguments()\n        \n    def _setup_arguments(self):\n        \"\"\"Configure command line arguments\"\"\"\n        self.parser.add_argument('--days', type=int, help='Number of past days to analyze')\n        self.parser.add_argument('--plot', action='store_true', help='Generate and display charts')\n        self.parser.add_argument('--output', help='Save report to file')\n        self.parser.add_argument('--category', help='Update category for an expense')\n        self.parser.add_argument('--index', type=int, help='Index of expense to update')\n    \n    def parse_args(self):\n        \"\"\"Parse command line arguments\"\"\"\n        return self.parser.parse_args()\n    \n    def display_report(self, expenses: List[Expense], analytics: Dict[str, Any]):\n        \"\"\"Display expense report in the terminal\n        \n        Args:\n            expenses: List of expenses\n            analytics: Analytics results\n        \"\"\"\n        print(\"\\n===== EXPENSE REPORT =====\")\n        print(f\"Total Spent: AED {analytics['total_spent']:.2f}\")\n        \n        print(\"\\n----- Category Breakdown -----\")\n        category_data = [\n            (category, f\"AED {amount:.2f}\", f\"{(amount/analytics['total_spent'])*100:.1f}%\") \n            for category, amount in analytics['category_totals'].items()\n        ]\n        print(tabulate(category_data, headers=[\"Category\", \"Amount\", \"Percentage\"], tablefmt=\"grid\"))\n        \n        print(\"\\n----- Top Merchants -----\")\n        merchant_data = [\n            (merchant, f\"AED {amount:.2f}\") \n            for merchant, amount in analytics['top_merchants'].items()\n        ]\n        print(tabulate(merchant_data, headers=[\"Merchant\", \"Amount\"], tablefmt=\"grid\"))\n        \n        print(\"\\n----- Recent Transactions -----\")\n        recent_data = [\n            (i, exp.merchant, f\"AED {exp.amount:.2f}\", exp.category) \n            for i, exp in enumerate(expenses[:10])  # Last 10 transactions\n        ]\n        print(tabulate(recent_data, headers=[\"Index\", \"Merchant\", \"Amount\", \"Category\"], tablefmt=\"grid\"))\n        \n        if analytics.get('monthly_summary'):\n            print(\"\\n----- Monthly Summary -----\")\n            monthly_data = [\n                (month, f\"AED {amount:.2f}\") \n                for month, amount in sorted(analytics['monthly_summary'].items())\n            ]\n            print(tabulate(monthly_data, headers=[\"Month\", \"Total\"], tablefmt=\"grid\"))\n```\n\n#### `src/ui/visualization.py`\n```python\nfrom typing import Dict, Any\nimport matplotlib.pyplot as plt\n\nclass ExpenseVisualizer:\n    \"\"\"Visualizes expense data using charts\"\"\"\n    \n    def generate_charts(self, analytics: Dict[str, Any]):\n        \"\"\"Generate and display expense charts\n        \n        Args:\n            analytics: Analytics results\n        \"\"\"\n        plt.figure(figsize=(12, 10))\n        \n        # Pie chart for category distribution\n        plt.subplot(2, 1, 1)\n        categories = list(analytics[\"category_totals\"].keys())\n        amounts = list(analytics[\"category_totals\"].values())\n        plt.pie(amounts, labels=categories, autopct='%1.1f%%')\n        plt.title('Expenses by Category')\n        \n        # Bar chart for top merchants\n        plt.subplot(2, 1, 2)\n        merchants = list(analytics[\"top_merchants\"].keys())\n        merchant_amounts = list(analytics[\"top_merchants\"].values())\n        plt.bar(merchants, merchant_amounts)\n        plt.title('Top Merchants')\n        plt.xticks(rotation=45, ha='right')\n        \n        # Add monthly trend if available\n        if analytics.get('monthly_summary') and len(analytics['monthly_summary']) > 1:\n            plt.figure(figsize=(10, 6))\n            months = sorted(analytics['monthly_summary'].keys())\n            monthly_amounts = [analytics['monthly_summary'][month] for month in months]\n            plt.plot(months, monthly_amounts, marker='o')\n            plt.title('Monthly Expense Trend')\n            plt.xlabel('Month')\n            plt.ylabel('Amount (AED)')\n            plt.xticks(rotation=45)\n            plt.tight_layout()\n        \n        plt.tight_layout()\n        plt.show()\n```\n\n#### `src/utils/config.py`\n```python\nimport os\nimport json\nfrom typing import Dict, Any, List, Optional\n\nclass Config:\n    \"\"\"Configuration management\"\"\"\n    \n    def __init__(self, config_file: str = \"config.json\"):\n        \"\"\"Initialize configuration\n        \n        Args:\n            config_file: Path to config file\n        \"\"\"\n        self.config_file = config_file\n        self.config = self._load_config()\n    \n    def _load_config(self) -> Dict[str, Any]:\n        \"\"\"Load configuration from file\"\"\"\n        default_config = {\n            \"db_path\": \"/Users/romannovikov/Library/Messages/chat.db\",\n            \"data_file\": \"expenses.json\"\n        }\n        \n        if os.path.exists(self.config_file):\n            try:\n                with open(self.config_file, 'r') as f:\n                    return json.load(f)\n            except:\n                return default_config\n        else:\n            # Save default config\n            with open(self.config_file, 'w') as f:\n                json.dump(default_config, f, indent=2)\n            return default_config\n    \n    def save_config(self):\n        \"\"\"Save configuration to file\"\"\"\n        with open(self.config_file, 'w') as f:\n            json.dump(self.config, f, indent=2)\n    \n    def get(self, key: str, default: Any = None) -> Any:\n        \"\"\"Get configuration value\"\"\"\n        return self.config.get(key, default)\n    \n    def set(self, key: str, value: Any):\n        \"\"\"Set configuration value\"\"\"\n        self.config[key] = value\n        self.save_config()\n\nclass ExpenseStore:\n    \"\"\"Store for persisting categorized expenses\"\"\"\n    \n    def __init__(self, data_file: str = \"expenses.json\"):\n        \"\"\"Initialize expense store\n        \n        Args:\n            data_file: Path to data file\n        \"\"\"\n        self.data_file = data_file\n    \n    def save_expenses(self, expenses: List[Dict[str, Any]]):\n        \"\"\"Save expenses to file\n        \n        Args:\n            expenses: List of expense dictionaries\n        \"\"\"\n        with open(self.data_file, 'w') as f:\n            json.dump(expenses, f, indent=2)\n    \n    def load_expenses(self) -> List[Dict[str, Any]]:\n        \"\"\"Load expenses from file\n        \n        Returns:\n            List of expense dictionaries\n        \"\"\"\n        if os.path.exists(self.data_file):\n            try:\n                with open(self.data_file, 'r') as f:\n                    return json.load(f)\n            except:\n                return []\n        return []\n    \n    def update_expense_category(self, index: int, category: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Update category for a specific expense\n        \n        Args:\n            index: Index of expense to update\n            category: New category\n            \n        Returns:\n            Updated expense or None if index is invalid\n        \"\"\"\n        expenses = self.load_expenses()\n        \n        if 0 <= index < len(expenses):\n            expenses[index][\"category\"] = category\n            self.save_expenses(expenses)\n            return expenses[index]\n        \n        return None\n```\n\n#### `src/utils/date_utils.py`\n```python\nfrom datetime import datetime, timedelta\nfrom typing import Optional\n\ndef get_date_threshold(days: int) -> datetime:\n    \"\"\"Get date threshold for filtering\n    \n    Args:\n        days: Number of days back\n        \n    Returns:\n        Datetime threshold\n    \"\"\"\n    return datetime.now() - timedelta(days=days)\n\ndef format_date(date: Optional[datetime]) -> str:\n    \"\"\"Format date for display\n    \n    Args:\n        date: Date to format\n        \n    Returns:\n        Formatted date string\n    \"\"\"\n    if not date:\n        return \"Unknown\"\n    \n    return date.strftime(\"%Y-%m-%d %H:%M\")\n```\n\n#### `src/main.py`\n```python\nimport logging\nimport json\nimport sys\nfrom typing import List\n\nfrom src.db.data_source import MessageDatabase\nfrom src.models.expense import Expense\nfrom src.services.parser import extract_payment_details, convert_imessage_date\nfrom src.services.categorizer import ExpenseCategorizer\nfrom src.services.analytics import ExpenseAnalyzer\nfrom src.ui.cli import ExpenseTrackerCLI\nfrom src.ui.visualization import ExpenseVisualizer\nfrom src.utils.config import Config, ExpenseStore\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\ndef process_messages(messages, categorizer):\n    \"\"\"Process messages into expense objects\"\"\"\n    expenses = []\n    \n    for message in messages:\n        # Extract payment details\n        details = extract_payment_details(message[\"text\"])\n        \n        # Convert date if available\n        date = None\n        if \"date\" in message and message[\"date\"]:\n            date = convert_imessage_date(message[\"date\"])\n        \n        # Categorize the expense\n        category = categorizer.categorize(details[\"merchant\"])\n        \n        # Create expense object\n        expense = Expense(\n            amount=details[\"amount\"],\n            merchant=details[\"merchant\"],\n            category=category,\n            date=date,\n            message=details[\"message\"]\n        )\n        \n        expenses.append(expense)\n    \n    return expenses\n\ndef main():\n    \"\"\"Main entry point for the expense tracker CLI\"\"\"\n    try:\n        # Initialize components\n        config = Config()\n        cli = ExpenseTrackerCLI()\n        args = cli.parse_args()\n        \n        # Initialize data source\n        db_path = config.get(\"db_path\")\n        db = MessageDatabase(db_path)\n        \n        # Initialize services\n        categorizer = ExpenseCategorizer()\n        analyzer = ExpenseAnalyzer()\n        visualizer = ExpenseVisualizer()\n        expense_store = ExpenseStore(config.get(\"data_file\"))\n        \n        # Handle category update if requested\n        if args.category and args.index is not None:\n            result = expense_store.update_expense_category(args.index, args.category)\n            if result:\n                print(f\"Updated expense {args.index} category to {args.category}\")\n            else:\n                print(f\"Failed to update expense {args.index}\")\n            return\n        \n        # Fetch data\n        print(\"Fetching expenses from iMessage database...\")\n        messages = db.fetch_payment_messages(days=args.days)\n        \n        if not messages:\n            print(\"No payment messages found.\")\n            return\n        \n        # Process messages\n        print(f\"Processing {len(messages)} messages...\")\n        expenses = process_messages(messages, categorizer)\n        \n        # Save expenses\n        expense_dicts = [exp.to_dict() for exp in expenses]\n        expense_store.save_expenses(expense_dicts)\n        \n        # Analyze expenses\n        print(\"Analyzing expenses...\")\n        analytics = analyzer.analyze(expenses)\n        \n        # Display report\n        cli.display_report(expenses, analytics)\n        \n        # Generate charts if requested\n        if args.plot:\n            print(\"Generating charts...\")\n            visualizer.generate_charts(analytics)\n        \n        # Save report if requested\n        if args.output:\n            with open(args.output, 'w') as f:\n                json.dump({\n                    \"analytics\": analytics,\n                    \"expenses\": expense_dicts\n                }, f, indent=2)\n            print(f\"Report saved to {args.output}\")\n            \n    except Exception as e:\n        logger.error(f\"Error in main: {e}\", exc_info=True)\n        print(f\"An error occurred: {e}\")\n        return 1\n    \n    return 0\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n```\n\n## Setting Up the Project with uv\n\nNow let's create the project using uv:\n\n1. Create the directory structure:\n```bash\nmkdir -p expense-tracker/src/{db,models,services,ui,utils}\ntouch expense-tracker/src/__init__.py\ntouch expense-tracker/src/{db,models,services,ui,utils}/__init__.py\n```\n\n2. Copy each file into its appropriate location in the structure.\n\n3. Create a virtual environment and install dependencies:\n```bash\ncd expense-tracker\nuv venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\nuv pip install -r requirements.txt\n```\n\n4. Install the package in development mode:\n```bash\nuv pip install -e .\n```\n\n5. Run the application:\n```bash\nexpense-tracker\n# or\npython -m src.main\n```\n\n## Benefits of This Structure\n\n1. **Modularity**: Each component has a single responsibility, making code easier to understand and maintain.\n\n2. **Testability**: You can easily write tests for individual components without dependencies.\n\n3. **Extensibility**: Adding new features like a web interface or different data sources is straightforward.\n\n4. **Maintainability**: Clear separation of concerns makes the codebase easier to navigate and update.\n\n5. **Scalability**: This structure can accommodate growing complexity as you add more features.\n\n## Next Steps\n\n1. **Add Tests**: Create unit tests for the individual components to ensure reliability.\n\n2. **Data Validation**: Add more robust data validation to handle edge cases.\n\n3. **Web Interface**: Extend the project with a simple web interface using Flask or Streamlit.\n\n4. **Budget Planning**: Add features for setting budgets and tracking against them.\n\n5. **Machine Learning**: Implement ML-based categorization to improve accuracy.\n\nThis modular structure gives you a solid foundation for extending your expense tracker application while keeping it maintainable and well-organized.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":913}}},{"id":{"replica_id":0,"value":115},"start":1489,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":914}}},{"id":{"replica_id":0,"value":116},"start":10100,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":915}}},{"id":{"replica_id":0,"value":435},"start":10273,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":916}}},{"id":{"replica_id":0,"value":436},"start":33992,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":917}}}],"summary":"Expense Tracking App SQLAlchemy Implementation","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null}],"thought_process_output_sections":[]}